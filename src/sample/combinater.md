#パーサーコンビネータ : Bogdanp/elm-combine

パーサーコンビネータライブラリを使ってパーサーを書いてみます。

###コンビネータ

コンビネーターとは、関数を組み合わせて新しい関数を返す関数をそう言うそうです。
例えば２つの関数をとって一つにする合成演算子(<<)はコンビネータです。

```elm
(<<) : (b -> c) -> (a -> b) -> (a -> c)
(<<) g f x =
  g (f x)
```

###パーサー

パーサーとは文字（記号）列を受け取って、頭から一文字づつ読んでいって、何かをするプログラムを指します。

例えば

* 文字列を、定めたルール・仕様・文法にそったものか判断する。（判定、構文解析）
* 文字列を、定めたルール・仕様・文法にそって別の文字列に変換する。（書き換え、コンパイラ、トランスパイラ、翻訳）
* 文字列を定めたルール・仕様・文法にそって実行、解釈する。（DSLとかevalとか）
* 文字列の中から特定の文字列を検索する（これは正規表現ライブラリの方が得意なことが多い、パーサーコンビネータだと書くの難しい）

###パーサーコンビネータ

パーサーコンビネータライブラリとは、関数を構成してパーサー関数を作る関数のライブラリです。
パーサーを関数を組み合わせるように書くことが出来ます。

Elmパッケージライブラリには２つのパーサーコンビネータライブラリがあります。今回はエラー処理も処理している場所もわかるBogdanp/elm-combineというのを使います。

パーサーコンビネータライブラリは関数型プログラミングの練習になると思います。

メモ：パーサーコンビネータライブラリの多くは、Haskellのparsecライブラリを参考にしています。

メモ；他に似たツールとして「正規表現ライブラリ」と「パーサージェネレータ」があります。

正規表現は正規表現を渡すとその文字列のパターンマッチを自動生成します。
パーサージェネレータは構文規則を渡すと、その構文解析器を自動生成します。
それらと比べると、パーサーコンビネータは一文字づつ文字列を読んでくプログラム（パーサー）を書きやすくするツールと思います。


##実行

パーサーコンビネータでパーサーを作る前に実行する方法を先に見てみます。  
パーサーコンビネータはパーサーを作ったあとに、parse関数で実行します。

```elm
parse : Parser res -> String -> (Result res, Context)

```

parseはパーサーと対象文字列を受け取るとパースを実行し、結果とContextのタプルを返します。
Contextには、パースしたあと残った文字列（次のパーサーがパースする部分）と、どこまでパースしたかの文字数が入っています（次のパーサーの開始位置）。

使う例

```elm
targetStr = "aaaaa"

yourParser = many <| string "a"

result = parse yourParser targetStr   --(Ok ["a","a","a","a","a"],{ input = "", position = 5 })
```

パースに失敗すると、Errになります。

```
parse (string "ab") "abc"  --(Ok "ab",{ input = "c", position = 2 })
parse (string "ab") "x"    --(Err (["expected \"ab\""]),{ input = "x", position = 0 })
```

Errになるとエラー文が入っています。上記だと「ab」が必要と入っています。このエラー部分はいじることが出来ます。

##パーサを作る関数


正規表現だと勝手に読み飛ばしてくれたりしますが、
頭から読んでいきます

文字集合を書くのに便利


