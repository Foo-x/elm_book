
##Elm-Architectureの前身

Elm-Architectureの前身とは、Elmそのものです。
ElmはFRPでGUIなアプリケーションを記述する研究の成果で生まれました。
FRPですが、Rxのようなイベントストリーム系FRPとは違います。中身はオブジェクト指向のオブサーバーパターンに似たものです。（mailboxという概念があったりすこし違いますけど）

なので、ElmというDSLをブラウザ上で書くと、勝手にオブサーバーパターンでGUIを書いているということで、つまりは、オブサーバーパターンのGUI用のフレームワークを使っているのと同じということです。

ということで、Elm-Architectureの前身は、オブサーバー的GUI記述用DSL(Elm)がありました。

##Elm-Architectureの初期

Elmで多数のアプリケーションが生まれ始めた時、構造化の方法として書き方が統一されました。mailboxのアドレスを一つにして、コンポーネントがinit、model、update、という関数を提供してもらい、一番親になるライブラリ（StartApp）だけを公開すれば、各コンポーネントはフラクタル的にスケールします。

ここで、Elm-Architectureという考え方は公開されました。

この時点のElmとElm-Architectureを他と比べながら説明してみましょう。まず「他」には何があるでしょうか。

* HtmlはDOMはイベントに関数を登録することで、jsが動作して画面が動きます。これをとりあえずDOM方式と呼びます。
* ゲームなどでは、メインループを回して、関数を定期実行したり値を監視して画面をつくります。これをメインループ方式と呼びます。
* MVCとは今ではサーバーフレームワークで聞きますが、もとはGUIの構造化の方法です。
* MVVMとはmodel view viewmodelというわけかたで、microsoftが有名で、フロントエンドではangularがそう呼ばれたりしました。

構造化手法とは、ソースコードをそのフレームワークをつかってどう分けるかという話です。

MVCならmodelとviewと

そう分けさせるように、

おおまかに言うと、(1)ユーザーからの入力を受けて->(2)その入力によってアプリケーションの状態を更新して->(3)更新されたその状態を画面に表示して、ユーザーがその画面にアクションを起こす、すると最初に戻ってループ。という流れと構造です。

これが他とどう違うのかというと、
* ユーザーのイベントに関数を登録する方法(イベントハンドラー方式)だと、関数を登録していくネストが深くなったり、どこから値にアクセスしているかわからず、処理が散文しますが、Elm-Architectureは一箇所になります。

* Elm-Architectureの(2)では、ユーザーの入力と現在の状態を受け取って、新しい状態を返すupdate関数が登場します。
このupdate関数の型は以下のようになります。

```
update : Msg -> Model -> Model
```

Msgがユーザーの入力を表現した型、Modelがアプリ全体の状態を表現した型です。

update関数内では、主にユーザー入力によって処理を振り分けて、アプリ全体の状態を更新していきます。行う処理が一つに集まっているのはメインループ方式に似ています。

ユーザー入力があった時に、毎度update関数は呼ばれます。

ここまでが基本部分になります。

Elmアーキテクチュアはコミュニティの意見や、Elm言語の発展で、大きく２つの段階にわかれています。model、view、update、Messageという今ではビギナータイプといわれる「シンプルなバージョン」と、DBアクセスやhttpの非同期な接続や、エラーやそれに伴う復旧といった副作用、裏側の処理についても網羅した「Cmd/Subバージョン」があります。


そういえば、Flux系フレームワークの一つReduxと、Rx.jsを使ったフレームワークのSycle.jsはElmアーキテクチュアを参考にしたり言及したりしているのですが、その時点ではシンプルバージョンだけだったので、副作用といった処理の扱いについてそれぞれ別物になっている。らしいです
